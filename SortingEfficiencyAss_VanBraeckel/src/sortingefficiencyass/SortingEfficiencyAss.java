/*
 * Mitchell Van Braeckel
 * 24/11/2016
 * Sorting Eficiency Assignment
    https://docs.google.com/document/d/1-OYF11979YZfdwDsMM7lIjBmY1yi56eZsQLALb5rJjc/edit
    Write a program that will display a list of random numbers
        • The random numbers should be in the range from -10 000 to 10 000 (inclusive)
        • The random numbers should be displayed in two text areas:
            a) numbers unsorted✓
            b) numbers sorted✓
        • A user should have the choice of:
            a) the number of random numbers to display
                --> 10✓, 100✓, 1000✓, or 5000✓
            b) the order the numbers will be sorted in
                --> ascending✓
                --> descending✓
            c) which algorithm they would like to see the numbers sorted by:
                [The program will sort the original unsorted numbers using four sorting methods studied in this unit:]
                    --> selection sort✓✓, bubble sort✓✓, insertion sort✓✓, and QUICKSORT✓✓
        • The program will display the:
            a) number of times a loop was executed✗
            b) actual time (in milliseconds) that it took to complete each sort✗
        • The program should perform the 4 sorts on the same set of data, so that the results are directly comparable
            [This means you will need 4 identical arrays to perform the sorting on]✓
            [There is a static copy method available in the Arrays class]✓
        • A new set of random numbers should be generated and displayed each time the user selects the 'Sort Numbers' button✓

        ======================================== [STILL NEED txtAResults OUTPUT FOR loop counter AND actual time] =======================================
 */

package sortingefficiencyass;

// imports
import java.util.Random;
import javax.swing.JOptionPane;
import java.text.DecimalFormat;

public class SortingEfficiencyAss extends javax.swing.JFrame {
    // declare imports
    Random r = new Random();
    DecimalFormat wf = new DecimalFormat("#,###,###,###,##0");
    // declare global variables
        // loop counters
    static int selectionC = 0;
    static int bubbleC = 0;
    static int insertionC = 0;
    static int quickC = 0;
    /**
     * Creates new form SortingEfficiencyAss
     */
    public SortingEfficiencyAss() {
        initComponents();
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        grpSortNum = new javax.swing.ButtonGroup();
        grpSortOrder = new javax.swing.ButtonGroup();
        lblTitle = new javax.swing.JLabel();
        lblSortNum = new javax.swing.JLabel();
        rdo10 = new javax.swing.JRadioButton();
        rdo100 = new javax.swing.JRadioButton();
        rdo1000 = new javax.swing.JRadioButton();
        rdo5000 = new javax.swing.JRadioButton();
        lblSortType = new javax.swing.JLabel();
        cboSortType = new javax.swing.JComboBox();
        lblSortOrder = new javax.swing.JLabel();
        rdoAscending = new javax.swing.JRadioButton();
        rdoDescending = new javax.swing.JRadioButton();
        btnSort = new javax.swing.JButton();
        lblOriginal = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtAOriginal = new javax.swing.JTextArea();
        lblSorted = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtASorted = new javax.swing.JTextArea();
        lblResults = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtAResults = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Sorting Efficiency Assignment - Mitchell Van Braeckel");

        lblTitle.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        lblTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTitle.setText("Sorting Efficiency Assignment");

        lblSortNum.setText("Amount of numbers to sort:");

        grpSortNum.add(rdo10);
        rdo10.setText("10");

        grpSortNum.add(rdo100);
        rdo100.setText("100");

        grpSortNum.add(rdo1000);
        rdo1000.setText("1000");

        grpSortNum.add(rdo5000);
        rdo5000.setText("5000");

        lblSortType.setText("Display numbers sorted by:");

        cboSortType.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Selection Sort", "Bubble Sort", "Insertion Sort", "Quicksort" }));

        lblSortOrder.setText("Sort Order:");

        grpSortOrder.add(rdoAscending);
        rdoAscending.setText("Ascending");

        grpSortOrder.add(rdoDescending);
        rdoDescending.setText("Descending");

        btnSort.setText("Sort");
        btnSort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSortActionPerformed(evt);
            }
        });

        lblOriginal.setText("Original Numbers:");

        txtAOriginal.setEditable(false);
        txtAOriginal.setColumns(20);
        txtAOriginal.setRows(5);
        jScrollPane1.setViewportView(txtAOriginal);

        lblSorted.setText("Sorted Numbers:");

        txtASorted.setEditable(false);
        txtASorted.setColumns(20);
        txtASorted.setRows(5);
        jScrollPane2.setViewportView(txtASorted);

        lblResults.setText("Sort Results:");

        txtAResults.setEditable(false);
        txtAResults.setColumns(20);
        txtAResults.setRows(5);
        jScrollPane3.setViewportView(txtAResults);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 253, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 253, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblOriginal)
                        .addGap(186, 186, 186)
                        .addComponent(lblSorted))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblSortType)
                        .addGap(18, 18, 18)
                        .addComponent(cboSortType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(lblTitle, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                            .addComponent(lblSortNum)
                            .addGap(18, 18, 18)
                            .addComponent(rdo10)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(rdo100)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(rdo1000)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(rdo5000)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblSortOrder)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(rdoDescending)
                            .addComponent(rdoAscending))
                        .addGap(18, 18, 18)
                        .addComponent(btnSort, javax.swing.GroupLayout.PREFERRED_SIZE, 172, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblResults)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 298, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblTitle)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblSortNum)
                            .addComponent(rdo10)
                            .addComponent(rdo100)
                            .addComponent(rdo1000)
                            .addComponent(rdo5000))
                        .addGap(18, 18, 18))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(lblResults)
                        .addGap(6, 6, 6)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblSortType)
                            .addComponent(cboSortType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(rdoAscending)
                                    .addComponent(lblSortOrder))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(rdoDescending))
                            .addComponent(btnSort, javax.swing.GroupLayout.PREFERRED_SIZE, 53, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblOriginal)
                            .addComponent(lblSorted))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 284, Short.MAX_VALUE)))
                    .addComponent(jScrollPane3))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnSortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSortActionPerformed
        // declare needed variables
        boolean goSort = true;
        int amountNums = 0;
        // retrieves the amount of rnd numbers to sort
        if(rdo10.isSelected()) {
            amountNums = 10;
        } else if(rdo100.isSelected()) {
            amountNums = 100;
        } else if(rdo1000.isSelected()) {
            amountNums = 1000;
        } else if(rdo5000.isSelected()) {
            amountNums = 5000;
        } else { // else (nothing isSelected, so don't run)
            goSort = false;
        } // end if
        
        // only runs if a rdo btn for amount of rnd #s is selected
        if(goSort) {
            String originalDisplay = "";    //holds output for list of original #s
            // generate an array with the specified amount of rnd numbers
            int original[] = new int[amountNums];
            //loads the array with rnd #s (-10,000 -> 10,000 inclusive)
            for (int i = 0; i < amountNums; i++) {
                original[i] = r.nextInt(20001) - 10000;
                // accumulate list of original numbers
                originalDisplay += i + ":\t" + original[i] + "\n";
            } // end for loop
            txtAOriginal.setText(originalDisplay);  //sets txtA text
            
            // creates a copy of the original array for each different sort algorithm
            int selectionCopy[] = new int[amountNums];
            int bubbleCopy[] = new int[amountNums];
            int insertionCopy[] = new int[amountNums];
            int quickCopy[] = new int[amountNums];
            // copies the entire original array
            System.arraycopy(original, 0, selectionCopy, 0, amountNums);
            System.arraycopy(original, 0, bubbleCopy, 0, amountNums);
            System.arraycopy(original, 0, insertionCopy, 0, amountNums);
            System.arraycopy(original, 0, quickCopy, 0, amountNums);
            
            // declare varaibles to track runtime of sorting algorithms
            long selectionTimeStart, selectionTimeEnd, selectionTimeElapsed;
            long bubbleTimeStart, bubbleTimeEnd, bubbleTimeElapsed;
            long insertionTimeStart, insertionTimeEnd, insertionTimeElapsed;
            long quickTimeStart, quickTimeEnd, quickTimeElapsed;
            // reset loop counters
            selectionC = 0;
            bubbleC = 0;
            insertionC = 0;
            quickC = 0;
            
            // check the order the array is to be sorted
            if(rdoAscending.isSelected()) {
                // each algorithm sorts the copy of the original array
                // also tracks time algorithm took to sort
                selectionTimeStart = System.currentTimeMillis();
                selectionSortA(selectionCopy);
                selectionTimeEnd = System.currentTimeMillis();
                selectionTimeElapsed = selectionTimeEnd - selectionTimeStart;
                
                bubbleTimeStart = System.currentTimeMillis();
                bubbleSortA(bubbleCopy);
                bubbleTimeEnd = System.currentTimeMillis();
                bubbleTimeElapsed = bubbleTimeEnd - bubbleTimeStart;
                
                insertionTimeStart = System.currentTimeMillis();
                insertionSortA(insertionCopy);
                insertionTimeEnd = System.currentTimeMillis();
                insertionTimeElapsed = insertionTimeEnd - insertionTimeStart;
                
                quickTimeStart = System.currentTimeMillis();
                quicksortA(quickCopy, 0, quickCopy.length-1);
                quickTimeEnd = System.currentTimeMillis();
                quickTimeElapsed = quickTimeEnd - quickTimeStart;
                
                txtASorted.setText(""); //reset
                // display the sorted copy of the original array in the txtA that was sorted with the chosen sorting algorithm
                displaySortedArray(selectionCopy, bubbleCopy, insertionCopy, quickCopy);
                // displays loop counter and time results for each sorting algorithm
                displayResults(selectionTimeElapsed, bubbleTimeElapsed, insertionTimeElapsed, quickTimeElapsed);
            
            } else if(rdoDescending.isSelected()){
                // each algorithm sorts the copy of the original array
                // also tracks time algorithm took to sort
                selectionTimeStart = System.currentTimeMillis();
                selectionSortD(selectionCopy);
                selectionTimeEnd = System.currentTimeMillis();
                selectionTimeElapsed = selectionTimeEnd - selectionTimeStart;
                
                bubbleTimeStart = System.currentTimeMillis();
                bubbleSortD(bubbleCopy);
                bubbleTimeEnd = System.currentTimeMillis();
                bubbleTimeElapsed = bubbleTimeEnd - bubbleTimeStart;
                
                insertionTimeStart = System.currentTimeMillis();
                insertionSortD(insertionCopy);
                insertionTimeEnd = System.currentTimeMillis();
                insertionTimeElapsed = insertionTimeEnd - insertionTimeStart;
                
                quickTimeStart = System.currentTimeMillis();
                quicksortD(quickCopy, 0, quickCopy.length-1);
                quickTimeEnd = System.currentTimeMillis();
                quickTimeElapsed = quickTimeEnd - quickTimeStart;
                
                txtASorted.setText(""); //reset
                // display the sorted copy of the original array in the txtA that was sorted with the chosen sorting algorithm
                displaySortedArray(selectionCopy, bubbleCopy, insertionCopy, quickCopy);
                // displays loop counter and time results for each sorting algorithm
                displayResults(selectionTimeElapsed, bubbleTimeElapsed, insertionTimeElapsed, quickTimeElapsed);
                
            } else {
                txtASorted.setText("");     //reset
                txtAResults.setText("");    //reset
                // display error msg
                JOptionPane.showMessageDialog(null, "A sorting order must be selected.\nPlease try again.",
                        "ERROR", JOptionPane.ERROR_MESSAGE);
            } // end if
        } else {
            // display error msg
            JOptionPane.showMessageDialog(null, "An amount of numbers to sort must be selected.\nPlease try again.",
                    "ERROR", JOptionPane.ERROR_MESSAGE);
        } // end if
    }//GEN-LAST:event_btnSortActionPerformed
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SortingEfficiencyAss.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SortingEfficiencyAss.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SortingEfficiencyAss.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SortingEfficiencyAss.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SortingEfficiencyAss().setVisible(true);
            } // end run()
        }); // end Runnable()
    } // end main
    // =========================================================================
    /**
     * Displays loop counter and time results for each sorting algorithm
     * @param selectionTimeElapsed the time it took for the Selection Sort algorithm
     * @param bubbleTimeElapsed the time it took for the Bubble Sort algorithm
     * @param insertionTimeElapsed the time it took for the Insertion Sort algorithm
     * @param quickTimeElapsed the time it took for the Quicksort algorithm
     */
    public void displayResults(long selectionTimeElapsed, long bubbleTimeElapsed, long insertionTimeElapsed, long quickTimeElapsed) {
        // declare needed variables
        String numLoops = "Number of times a loop was executed: ";
        String time = "Number of milliseconds to complete sort: ";
        // display loop and time results for each sorting algorithm
        txtAResults.setText("Selection Sort:\n" +
                numLoops + wf.format(selectionC) + "\n" +
                time + selectionTimeElapsed +
                "\nBubble Sort:\n" +
                numLoops + wf.format(bubbleC) + "\n" +
                time + bubbleTimeElapsed +
                "\nInsertion Sort:\n" +
                numLoops + wf.format(insertionC) + "\n" +
                time + insertionTimeElapsed +
                "\nQuicksort:\n" +
                numLoops + wf.format(quickC) + "\n" +
                time + quickTimeElapsed);
    } // end displayResults()
    /**
     * Displays the copy of the original array sorted with the desired sorting algorithm
     * @param selectionCopy the copy of the original array to be sorted using Selection Sort
     * @param bubbleCopy the copy of the original array to be sorted using Bubble Sort
     * @param insertionCopy the copy of the original array to be sorted using Insertion Sort
     * @param quickCopy the copy of the original array to be sorted using Quicksort
     */
    public void displaySortedArray(int selectionCopy[], int bubbleCopy[], int insertionCopy[], int quickCopy[]) {
        String sortedDisplay = "";  //holds output for list of sorted #s
        // check which sort type is chosen to be displayed
        // and accumulate list of sorted #s for that sort algorithm
        if(cboSortType.getSelectedItem().equals("Selection Sort")) {
            for (int i = 0; i < selectionCopy.length; i++) {
                sortedDisplay += i + ":\t" + selectionCopy[i] + "\n";
            } // end for loop
        } else if(cboSortType.getSelectedItem().equals("Bubble Sort")) {
            for (int i = 0; i < bubbleCopy.length; i++) {
                sortedDisplay += i + ":\t" + bubbleCopy[i] + "\n";
            } // end for loop
        } else if(cboSortType.getSelectedItem().equals("Insertion Sort")) {
            for (int i = 0; i < insertionCopy.length; i++) {
                sortedDisplay += i + ":\t" + insertionCopy[i] + "\n";
            } // end for loop
        } else if(cboSortType.getSelectedItem().equals("Quicksort")) {
            for (int i = 0; i < quickCopy.length; i++) {
                sortedDisplay += i + ":\t" + quickCopy[i] + "\n";
            } // end for loop
        } // end if (all possibilities above)
        txtASorted.setText(sortedDisplay);  //sets txtA text
    } // end displaySortedArray()
    // =========================================================================
    // =========================================================================
    /**
     * Sorts an array of integers using Selection Sort algorithm in Ascending order
     * @param nums the array of integers to be sorted
     */
    public static void selectionSortA(int nums[]) {
        int min;    //declare needed variables
        // loop through entire array
        for (int i = 0; i < nums.length; i++) {
            min = i;                    // Assume first element is min
            // loop though entire array after above value
            for (int j = i+1; j < nums.length; j++) {
                if (nums[j] < nums[min]) {
                    min = j;            //set index of new min
                } // end if
                selectionC++;           //accumulate loop counter
            } // end for loop-2nd level j
            if (min != i) {
                // swaps lower value on right with a higher value on left
                int temp = nums[i];     //sets as holder for 1st level value
                nums[i] = nums[min];    //sets min value in array back a position
                nums[min] = temp;       //sets new min
            } // end if
        } // end for loop-1st level i
    } // end selectionSortA()
    /**
     * Sorts an array of integers using Selection Sort algorithm in DEscending order
     * @param nums the array of integers to be sorted
     */
    public static void selectionSortD(int nums[]) {
        int max;                        // declare needed variables
        // loop through entire array
        for (int i = 0; i < nums.length; i++) {
            max = i;                    // Assume first element is max
            // loop though entire array after above value
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] > nums[max]) {
                    max = j;            //set index of new max
                } // end if
                selectionC++;           //accumulate loop counter
            } // end for loop-2nd level j
            if (max != i) {
                // swaps higher value on right with a lower value on left
                int temp = nums[i];      //sets as holder for 1st level value
                nums[i] = nums[max];     //sets min value in array back a position
                nums[max] = temp;        //sets new max
            } // end if
        } // end for loop-1st level i
    } // end selectionSortD()
    // =========================================================================
    /**
     * Sorts an array of integers using Bubble Sort algorithm in Ascending order
     * @param nums the array of integers to be sorted
     */
    public static void bubbleSortA(int nums[]) {
        boolean flag = true;    //set flag to true to begin first pass
        int j = 0;              //how much the end of the array has been sorted
        int temp;               //temporary holding variable
        // runs until a swap didn't occur during a loop through of entire array
        while(flag){
            flag = false;       //set flag to false awaiting a possible swap
            j++;                //accumulate since each iteration the first and last values are sorted
            // run through the unsorted part of array
            for(int i = 0; i < nums.length - j; i++){
                // check if the current value is greater than the next value
                if(nums[i] > nums[i+1]) {
                    // swaps lower value on right with a higher value on left
                    temp = nums[i];
                    nums[i] = nums[i+1];
                    nums[i+1] = temp;
                    flag = true;            //shows a swap occurred  
                } // end if
                bubbleC++;                  //accumulate loop counter
            } // end for loop
        } // end while loop
    } // end bubbleSortA()
    /**
     * Sorts an array of integers using Bubble Sort algorithm in DEscending order
     * @param nums the array of integers to be sorted
     */
    public static void bubbleSortD(int nums[]) {
        boolean flag = true;    //set flag to true to begin first pass
        int j = 0;              //how much the end of the array has been sorted
        int temp;               //temporary holding variable
        // runs until a swap didn't occur during a loop through of entire array
        while(flag){
            flag = false;       //set flag to false awaiting a possible swap
            j++;                //accumulate since each iteration the first and last values are sorted
            // run through the unsorted part of array
            for(int i = 0; i < nums.length - j; i++){
                // check if the current value is greater than the next value
                if(nums[i] < nums[i+1]) {
                    // swaps lower value on left with a higher value on right
                    temp = nums[i];
                    nums[i] = nums[i+1];
                    nums[i+1] = temp;
                    flag = true;            //shows a swap occurred  
                } // end if
                bubbleC++;                  //accumulate loop counter
            } // end for loop
        } // end while loop
    } // end bubbleSortD()
    // =========================================================================
    /**
     * Sorts an array of integers using Insertion Sort algorithm in Ascending order
     * @param nums the array of integers to be sorted
     */
    public static void insertionSortA(int nums[]) {
        int j, temp;    // declare needed variables
        // loop through entire array
        for(int i = 1; i < nums.length; i++) {
            j = i - 1;  //sets j to index of i
            // loops until j is negative OR the value at index j is less than value at index i
            while(j >= 0 && nums[j] > nums[i]) {
                // swaps lower value on right with a higher value on left
                temp = nums[i];     //sets as holder for 1st level value
                nums[i] = nums[j];  //sets min value in array back a position
                nums[j] = temp;     //sets new min
                i = j;              //sets i to j, since j is on left side i
                j--;                //disipate j, moves backwards in array index
                insertionC++;       //accumulate loop counter
            } // end while loop
        } // end for loop
    } // end insertionSortA()
    /**
     * Sorts an array of integers using Insertion Sort algorithm in DEcending order
     * @param nums the array of integers to be sorted
     */
    public static void insertionSortD(int nums[]) {
        int j, temp;    // declare needed variables
        // loop through entire array
        for (int i = 1; i < nums.length; i++) {
            j = i - 1;  //sets j to index of i-1
            // loops until j is negative OR the value at index j is greater than value at index i
            while (j >= 0 && nums[j] < nums[i] ) {
                // swaps lower value on left with a higher value on right
                temp = nums[i];     //sets as holder for 1st level value
                nums[i] = nums[j];  //sets min value in array back a position
                nums[j] = temp;     //sets new min
                i = j;              //sets i to j, since j is on left side i
                j--;                //disipate j, moves backwards in array index
                insertionC++;       //accumulate loop counter
            } // end while loop
        } // end for loop
    } // end insertionSortD()
    // =========================================================================
    /**
     * Sorts an array of integers using Quicksort algorithm in Ascending order
     * @param nums the array of integers to be sorted
     * @param lowIndex the lowest index of the segment of array
     * @param highIndex the highest index of the segment of array
     */
    public static void quicksortA(int nums[], int lowIndex, int highIndex) {
        // checks if lowIndex < highIndex
        if (lowIndex < highIndex) {
            // q is the index of the pivot
            int q = partitionA(nums, lowIndex, highIndex);   //actually sorts values in array (sorts the pivot)
            quicksortA(nums, lowIndex, q);                  //recursive call to left half of pivot (inclusive)
            quicksortA(nums, q+1, highIndex);               //recursive call to right half of pivot (exclusive)
        } // end if
    } // end quicksortA
    /**
     * Sorts the pivot (for Ascending order)
     * @param nums the array of integers to be sorted
     * @param lowIndex the lowest index of the segment of array
     * @param highIndex the highest index of the segment of array
     * @return the index of the pivot
     */
    public static int partitionA(int nums[], int lowIndex, int highIndex) {
        // declare needed variables
        int x = nums[lowIndex]; //pivot's value
        int i = lowIndex;       //lowIndex
        int j = highIndex;      //highIndex
        // runs until value is returned when i > j
        while(true) {
            // ignores all the numbers < x to left
            while (nums[i] < x) {
                i++;
                quickC++;           //accumulate loop counter
            } // end while loop
            //ignore all numbers > x to right
            while (nums[j] > x) {
                j--;
                quickC++;           //accumulate loop counter
            } // end while loop
            // checks if lowIndex < highIndex
            if (i < j) {
                // swaps a value higher than x with a lower value right of x
                int temp = nums[i]; //sets as holder for 1st level value
                nums[i] = nums[j];  //sets min value in array back a position
                nums[j] = temp;     //sets new min
                i++;                //accumulate
                j--;                //dissipate
            } else {
                return j;
            } // end if
       } // end while loop
    } // end partitionA()
    /**
     * Sorts an array of integers using Quicksort algorithm in DEscending order
     * @param nums the array of integers to be sorted
     * @param lowIndex the lowest index of the segment of array
     * @param highIndex the highest index of the segment of array
     */
    public static void quicksortD(int nums[], int lowIndex, int highIndex) {
        // checks if lowIndex < highIndex
        if (lowIndex < highIndex) {
            // q is the index of the pivot
            int q = partitionD(nums, lowIndex, highIndex);  //actually sorts values in array (sorts the pivot)
            quicksortD(nums, lowIndex, q);                  //recursive call to left half of pivot (inclusive)
            quicksortD(nums, q+1, highIndex);               //recursive call to right half of pivot (exclusive)
        } // end if
    } // end quicksortD
    /**
     * Sorts the pivot (for DEscending order)
     * @param nums the array of integers to be sorted
     * @param lowIndex the lowest index of the segment of array
     * @param highIndex the highest index of the segment of array
     * @return the index of the pivot
     */
    public static int partitionD(int nums[], int lowIndex, int highIndex) {
        // declare needed variables
        int x = nums[lowIndex]; //pivot's value
        int i = lowIndex;       //lowIndex
        int j = highIndex;      //highIndex
        // runs until value is returned when i > j
        while(true) {
            // ignores all the numbers > x to left
            while (nums[i] > x) {
                i++;
                quickC++;           //accumulate loop counter
            } // end while loop
            //ignore all numbers < x to right
            while (nums[j] < x) {
                j--;
                quickC++;           //accumulate loop counter
            } // end while loop
            // checks if lowIndex < highIndex
            if (i < j) {
                // swaps a value lower than x with a higher value right of x
                int temp = nums[i]; //sets as holder for 1st level value
                nums[i] = nums[j];  //sets min value in array back a position
                nums[j] = temp;     //sets new min
                i++;                //accumulate
                j--;                //dissipate
            } else {
                return j;
            } // end if
       } // end while loop
    } // end partitionD()
    // =========================================================================
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnSort;
    private javax.swing.JComboBox cboSortType;
    private javax.swing.ButtonGroup grpSortNum;
    private javax.swing.ButtonGroup grpSortOrder;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JLabel lblOriginal;
    private javax.swing.JLabel lblResults;
    private javax.swing.JLabel lblSortNum;
    private javax.swing.JLabel lblSortOrder;
    private javax.swing.JLabel lblSortType;
    private javax.swing.JLabel lblSorted;
    private javax.swing.JLabel lblTitle;
    private javax.swing.JRadioButton rdo10;
    private javax.swing.JRadioButton rdo100;
    private javax.swing.JRadioButton rdo1000;
    private javax.swing.JRadioButton rdo5000;
    private javax.swing.JRadioButton rdoAscending;
    private javax.swing.JRadioButton rdoDescending;
    private javax.swing.JTextArea txtAOriginal;
    private javax.swing.JTextArea txtAResults;
    private javax.swing.JTextArea txtASorted;
    // End of variables declaration//GEN-END:variables
} // end class
