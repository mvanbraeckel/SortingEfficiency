/*
 * Mitchell Van Braeckel
 * 17/11/2016
 * Searching Exercise
    1) Reads the data from BookList.txt into the program
        Write a class which represents a Book that contains:
            a) reference number (ID###)
            b) book title
        Create a new Book for each record in the datafile and adds it to an ArrayList
    2) Searches the ArrayList for the book with the given reference number (supplied by the user)
            If the reference number is found, display the title of that book,
            Otherwise display "Book # XX Not Found"
    3) Displays the number of Books the program had to examine before finding the desired book

    Your program is to:
        a) search for the book using both a linear and a binary search
        b) output the number of books that each search had to examine so that we may compare their efficiency

    NOTE: The total number of books is not known, therefore you should use ArrayLists.
 */

package searchingex;

// imports
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import javax.swing.JOptionPane;

public class SearchingEx extends javax.swing.JFrame {
    // declare needed variables
    static ArrayList<BookID> bookList = new ArrayList<>();
    static int booksProc = 0;
    static int bookIndex = 0;
    // =========================================================================
    /**
     * Creates new form SearchingEx
     */
    public SearchingEx() {
        initComponents();
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lblTitle = new javax.swing.JLabel();
        lblPic = new javax.swing.JLabel();
        lblDescription = new javax.swing.JLabel();
        lblInstructions = new javax.swing.JLabel();
        txtFEnter = new javax.swing.JTextField();
        btnFind = new javax.swing.JButton();
        lblSearchL = new javax.swing.JLabel();
        txtFSearchL = new javax.swing.JTextField();
        lblSearchB = new javax.swing.JLabel();
        txtFSearchB = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Searching Exercise: Children's Classics - Book Search");
        setLocation(new java.awt.Point(500, 200));

        lblTitle.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        lblTitle.setForeground(new java.awt.Color(255, 0, 0));
        lblTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTitle.setText("Children's Classics");

        lblPic.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblPic.setIcon(new javax.swing.ImageIcon(getClass().getResource("/searchingex/childrens-classics.jpg"))); // NOI18N

        lblDescription.setText("This program will find the title of a book according to the library reference ID number.");

        lblInstructions.setFont(new java.awt.Font("Engravers MT", 1, 12)); // NOI18N
        lblInstructions.setText("ENTER THE REFERENCE ID NUMBER:");

        txtFEnter.setText("4");

        btnFind.setText("Find It!");
        btnFind.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFindActionPerformed(evt);
            }
        });

        lblSearchL.setText("Linear Search:");

        txtFSearchL.setEditable(false);
        txtFSearchL.setText("--");

        lblSearchB.setText("Binary Search:");

        txtFSearchB.setEditable(false);
        txtFSearchB.setText("--");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(btnFind)
                            .addComponent(lblInstructions))
                        .addGap(18, 18, 18)
                        .addComponent(txtFEnter))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblTitle, javax.swing.GroupLayout.DEFAULT_SIZE, 342, Short.MAX_VALUE)
                        .addGap(18, 18, 18)
                        .addComponent(lblPic))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblDescription)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblSearchL)
                            .addComponent(lblSearchB))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(txtFSearchL)
                            .addComponent(txtFSearchB))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblTitle, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(lblPic, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(lblDescription)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblInstructions)
                    .addComponent(txtFEnter, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(btnFind)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblSearchL)
                    .addComponent(txtFSearchL, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblSearchB)
                    .addComponent(txtFSearchB, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnFindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFindActionPerformed
        // retrieve input
        String sNum = txtFEnter.getText();
        // check if input is good
        if(isNumeric(sNum)) {   //good input
            int num = Integer.parseInt(sNum);   //parse to int
            
            // linear search for matching title
            if(linearSearch(num)) { //found
                // display results
                txtFSearchL.setText("Found: " + bookList.get(booksProc-1).getTitle() + ".  " + booksProc + " books processed.");
            } else {                //not found
                // display results
                txtFSearchL.setText("Book #" + num + " is not in the list.");
            } // end if
            
            // binary search for matching title
            booksProc = 0;  //reset
            if(binarySearch(0, bookList.size()-1, num)) {   //found
                // display results
                txtFSearchB.setText("Found: " + bookList.get(bookIndex).getTitle() + ".  " + booksProc + " books processed.");
            } else {                                        //not found
                // display results
                txtFSearchB.setText("Book #" + num + " is not in the list.");
            } // end if
        } else {                //bad input
            // display error msg
            JOptionPane.showMessageDialog(null, "Invalid entry. Value entered must be an integer.\nPlease try again.", 
                    "Searching Exercise: Children's Classics - Book Search", JOptionPane.ERROR_MESSAGE);
        } // end if
    }//GEN-LAST:event_btnFindActionPerformed
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SearchingEx.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SearchingEx.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SearchingEx.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SearchingEx.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SearchingEx().setVisible(true);
            } // end run()
        });
        // =====================================================================
        readFile(); //read in data from BookList.txt for all books in the library
    } // end main
    
    /**
     * Assuming the list is sorted in ascending order, examines entire list of books 
     * from left to right stopping once a match is found
     * @param num the reference ID number being searched for
     * @return true if the desired target is found
     */
    public boolean linearSearch(int num){
        // examine the whole ArrayList of books
        for (int i = 0; i < bookList.size(); i++){
            // check if ID is a match
            if(bookList.get(i).getID() == num) {
                booksProc = i+1;    //set #of books processed
                return true;
            } else if(bookList.get(i).getID() > num){
                // check if already passed the desired book ID
                return false;
            } // end if
        } // end for loop
        // the entire array has been searched without finding the target
        return false;
    } // end linearSearch()
    /**
     * Assuming the list is sorted in ascending order, examines entire list of books recursively
     * until match is found using the middle as a starting point
     * @param left the index of the lowest point of the list segment
     * @param right the index of the highest point of the list segment
     * @param num the reference ID number being searched for
     * @return true if the desired target is found
     */
    public boolean binarySearch(int left, int right, int num){
        booksProc++;    //accumulate
        // determine the middle of this array section
        int middle = (left + right) / 2;
        
        if(left > right) {                                  //success base case
            // check if there is any list left to search
            return false;
        } else if (bookList.get(middle).getID() == num){    //failure base case
            // check if ID is a match with list middle value
            bookIndex = middle; //set
            return true;
        } else 
        // search the half of the list that might contain the target ID
        if (num < bookList.get(middle).getID()) { //search for ID on left half of list
            return binarySearch(left, middle - 1, num); //recursive call
            //left ---> still lowest end of list segment
            //right --> what middle used to be, except 1 more left, since already know that middle isn't target ID
        } else { // (id < num) --> right half of the list
            return binarySearch(middle + 1, right, num);
            //left --> what middle used to be, except 1 more right, since already know that middle isn't target ID
            //right --> still highest end of list segment
        } // end if
    } // end binarySearch()

    /**
     * Read in data from BookList.txt for all books in the library
     */
    public static void readFile() {
        // declare needed variables
        boolean eof = false;
        String line = "";
        int num = 0;
        String name = "";
        try {   // read in data from BookList.txt for all books in the library
            FileReader fr = new FileReader("src\\searchingex\\BookList.txt");
            BufferedReader br = new BufferedReader(fr);
            eof = false;
            while(!eof) {
                line = br.readLine();
                // check if anything is there
                if(line == null) {
                    eof = true; // stop reading
                } else {        // cont reading
                    // create a BookID and add it to the list
                    num = Integer.parseInt(line);
                    name = br.readLine();
                    bookList.add(new BookID(num, name));
                } // end if
            } // end while loop
        } catch(IOException e) {
            System.out.println("Error: " + e.toString());
        } // end try-catch
    } // end readFile()
    /**
     * Checks if a number entered by a number is an integer
     * @param sNum the value entered by the user
     * @return true if the value is parsed into an integer successfully
     */
    public static boolean isNumeric(String sNum) {
        try {
            Integer.parseInt(sNum);
            return true;
        } catch (NumberFormatException nfe) {
            return false;
        } // end try-catch
    } // end isNumeric()
     
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnFind;
    private javax.swing.JLabel lblDescription;
    private javax.swing.JLabel lblInstructions;
    private javax.swing.JLabel lblPic;
    private javax.swing.JLabel lblSearchB;
    private javax.swing.JLabel lblSearchL;
    private javax.swing.JLabel lblTitle;
    private javax.swing.JTextField txtFEnter;
    private javax.swing.JTextField txtFSearchB;
    private javax.swing.JTextField txtFSearchL;
    // End of variables declaration//GEN-END:variables
} // end class
